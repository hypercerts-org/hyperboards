create extension if not exists citext
    with
    schema extensions;


create table
    public.users
(
    id         uuid                     null,
    created_at timestamp with time zone not null default now(),
    auth       json                     not null default '{}'::json,
    email      text                     null,
    address    text                     not null,
    constraint users_pkey primary key (address)
) tablespace pg_default;




create table
    public.hyperboards
(
    id         uuid                     not null default gen_random_uuid(),
    created_at timestamp with time zone null     default now(),
    name       text                     not null,
    admin_id   text                     not null,
    chain_id   integer                  not null,
    constraint hyperboards_pkey primary key (id)
) tablespace pg_default;



create table
    public.registries
(
    id          uuid                     not null default gen_random_uuid(),
    created_at  timestamp with time zone not null default now(),
    name        text                     not null,
    description text                     not null,
    admin_id    text                     not null,
    hidden      boolean                  not null default false,
    chain_id    integer                  not null,
    constraint registries_optimism_pkey primary key (id)
) tablespace pg_default;

create table
    public.hyperboard_registries
(
    created_at    timestamp with time zone null default now(),
    hyperboard_id uuid                     not null,
    registry_id   uuid                     not null,
    constraint hyperboard_registries_pkey primary key (hyperboard_id, registry_id),
    constraint hyperboard_registries_hyperboard_id_fkey foreign key (hyperboard_id) references hyperboards (id),
    constraint hyperboard_registries_registry_id_fkey foreign key (registry_id) references registries (id)
) tablespace pg_default;

create table
    public.blueprints
(
    id             bigint generated by default as identity,
    created_at     timestamp with time zone not null default now(),
    admin_id       extensions.citext        not null,
    form_values    json                     not null,
    minter_address extensions.citext        not null,
    registry_id    uuid                     not null,
    constraint blueprints_pkey primary key (id),
    constraint blueprints_admin_id_fkey foreign key (admin_id) references users (address),
    constraint blueprints_registry_id_fkey foreign key (registry_id) references registries (id) on delete cascade
) tablespace pg_default;

create table
    public.claims
(
    id           uuid                     not null default gen_random_uuid(),
    created_at   timestamp with time zone not null default now(),
    registry_id  uuid                     not null,
    hypercert_id text                     not null,
    chain_id     integer                  not null,
    admin_id     extensions.citext        not null,
    owner_id     extensions.citext        not null,
    constraint hyperboard_claims_pkey primary key (id),
    constraint claims_registry_id_fkey foreign key (registry_id) references registries (id) on delete cascade
) tablespace pg_default;



create table
    public.default_sponsor_metadata
(
    id            uuid                     not null default gen_random_uuid(),
    created_at    timestamp with time zone not null default now(),
    type          text                     not null,
    "companyName" text                     null,
    "firstName"   text                     null,
    "lastName"    text                     null,
    image         text                     not null,
    address       extensions.citext        not null,
    constraint hyperboard_sponsor_metadata_pkey primary key (id)
) tablespace pg_default;


create table
    public.zuzalu_donations
(
    id         bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    address    text                     not null,
    email      text                     not null,
    amount     text                     null,
    constraint zuzalu_donations_pkey primary key (id)
) tablespace pg_default;

alter table "public"."hyperboard_registries"
    enable row level security;

alter table "public"."hyperboards"
    enable row level security;


alter table "public"."hyperboard_registries"
    validate constraint "hyperboard_registries_hyperboard_id_fkey";

alter table "public"."hyperboard_registries"
    add constraint "hyperboard_registries_registries_id_fkey" FOREIGN KEY (registry_id) REFERENCES registries (id) not valid;

alter table "public"."hyperboard_registries"
    validate constraint "hyperboard_registries_registries_id_fkey";

alter table "public"."users"
    enable row level security;


create policy "Enable insert for authenticated users only"
    on "public"."hyperboards"
    as permissive
    for insert
    to authenticated
    with check (true);


create policy "Enable read access for all users"
    on "public"."hyperboards"
    as permissive
    for select
    to public
    using (true);


create policy "Enable update for users based on address"
    on "public"."hyperboards"
    as permissive
    for update
    to public
    using (((auth.jwt() ->> 'address'::text) = admin_id))
    with check (((auth.jwt() ->> 'address'::text) = admin_id));

alter table "public"."claims"
    enable row level security;

alter table "public"."default_sponsor_metadata"
    enable row level security;

alter table "public"."registries"
    enable row level security;

create policy "Enable read access for all users"
    on "public"."claims"
    as permissive
    for select
    to public
    using (true);


create policy "Enable read access for all users"
    on "public"."hyperboard_registries"
    as permissive
    for select
    to public
    using (true);


create policy "Enable read access for all users"
    on "public"."default_sponsor_metadata"
    as permissive
    for select
    to public
    using (true);


create policy "Enable read access for all users"
    on "public"."registries"
    as permissive
    for select
    to public
    using (true);

alter table "public"."claims"
    drop constraint "claims_registry_id_fkey";

alter table "public"."claims"
    add constraint "claims_registry_id_fkey" FOREIGN KEY (registry_id) REFERENCES registries (id) ON DELETE CASCADE not valid;

alter table "public"."claims"
    validate constraint "claims_registry_id_fkey";

create policy "Enable insert for authenticated users only"
    on "public"."claims"
    as permissive
    for insert
    to authenticated
    with check (true);


create policy "Allow owners of registries to delete them based on address"
    on "public"."registries"
    as permissive
    for delete
    to public
    using (((auth.jwt() ->> 'address'::text) = admin_id));


create policy "Allow owners of registries to update based on address"
    on "public"."registries"
    as permissive
    for update
    to public
    using (((auth.jwt() ->> 'address'::text) = admin_id))
    with check (((auth.jwt() ->> 'address'::text) = admin_id));


create policy "Enable insert for authenticated users only"
    on "public"."registries"
    as permissive
    for insert
    to authenticated
    with check (true);


alter table "public"."zuzalu_donations"
    enable row level security;

create policy "Allow insert for everybody"
    on "public"."zuzalu_donations"
    as permissive
    for insert
    to public
    with check (true);

create policy "Delete claims when you are the owner"
    on "public"."claims"
    as permissive
    for delete
    to public
    using (((auth.jwt() ->> 'address'::text) = admin_id));


create policy "Only allow for owner of the hyperboard"
    on "public"."hyperboard_registries"
    as permissive
    for insert
    to public
    with check (((auth.jwt() ->> 'address'::text) IN (SELECT hyperboards.admin_id
                                                      FROM hyperboards
                                                      WHERE (hyperboard_registries.hyperboard_id = hyperboards.id))));

create policy "Only allow for owner of hyperboard"
    on "public"."hyperboard_registries"
    as permissive
    for delete
    to public
    using (((auth.jwt() ->> 'address'::text) IN (SELECT hyperboards.admin_id
                                                 FROM hyperboards
                                                 WHERE (hyperboard_registries.hyperboard_id = hyperboards.id))));


create policy "Enable delete for users based on address"
    on "public"."hyperboards"
    as permissive
    for delete
    to public
    using (((auth.jwt() ->> 'address'::text) = admin_id));

alter table "public"."blueprints" enable row level security;

create policy "Enable read access for all users"
    on "public"."blueprints"
    as permissive
    for select
    to public
    using (true);


create policy "Only owners of registry can add a blueprint to it"
    on "public"."blueprints"
    as permissive
    for insert
    to public
    with check (((auth.jwt() ->> 'address'::text) IN (SELECT registries.admin_id
                                                      FROM registries
                                                      WHERE (registries.id = blueprints.registry_id))));

create policy "Owners of blueprint or minters of blueprint can delete"
    on "public"."blueprints"
    as permissive
    for delete
    to public
    using ((((auth.jwt() ->> 'address'::text) = admin_id) OR ((auth.jwt() ->> 'address'::text) = minter_address)));
